## 一、计算机的三大部件

任何一台计算机内部都有三大部件——三大硬件，是作为软件开发工程师一定要了解的，它们就是：CPU、内存、硬盘。

> CPU是一个硬件产品，负责执行机器指令。CPU由寄存器、运算器、控制器等物理设备组成，CPU周围又有一圈地址总线、数据总线、控制总线等物理线路，寄存器主要负责临时存储参与运算的数据，运算器主要负责对数据进行运算，控制器主要负责控制内存条、麦克风、音响、显示器等外部设备，地址总线主要负责通过每根电线的高低电平来表征一个内存地址，数据总线主要负责传输数据，控制总线主要负责传输控制器的信号。这些物理设备和物理线路相互合作来一条一条地执行机器指令。
>
> 比如“int i1 = 10; int i2 = 20; int i3 = i1 + i2;”这段高级语言的代码，第三句代码对应的机器指令被CPU给执行到了，那控制器就会通过控制总线给内存条这个外部设备传输一个信号，告诉它现在CPU想要拿到地址总线上表征的那个内存地址——即变量i1所对应的内存的首地址——里的数据10，于是10这个数值就会通过数据总线回传到CPU的某个寄存器里，同理20这个数值也会通过数据总线回传到CPU的某个寄存器里，然后运算器就会把这两个寄存器里的数值相加得到30，30这个数值也会被存储到某个寄存器里，然后控制器又会通过控制总线给内存条这个外部设备传输一个信号，告诉它现在CPU想要把30这个数值存储进地址总线上表征的那个内存地址——即变量i3所对应的内存的首地址——里，于是30这个数值就会通过数据总线回传到内存条里。

|      |                        一般用来做什么                        |                   存储容量                   |   读写速度   |  计算机断电重启后  |
| :--: | :----------------------------------------------------------: | :------------------------------------------: | :----------: | :----------------: |
| 内存 | 所有的应用程序在打开后都是运行在内存中的，并且应用程序运行过程中所产生的数据也都默认存储在内存中，当然我们可以主动把这些数据存储到硬盘上 |         比硬盘小得多，比如8G、16G等          | 比硬盘快得多 | 存储的数据会被清空 |
| 硬盘 | 一般用来存储各种文件，如文本文件、图片文件、音频文件、视频文件、应用程序的可执行文件等 | 比内存大得多，比如128G、256G、512G、1T、2T等 | 比内存慢得多 | 存储的数据依然存在 |

#### 1、CPU相关的知识

###### 1.1 CPU架构

CPU架构是指生产CPU的公司给CPU这个硬件产品及其软件能力定义的一套硬件规范和软件规范，比如这套规范规定了寄存器的位数、总线的位数等硬件规范，也规定了CPU可以识别什么汇编生成的机器指令、以及机器指令的位数等软件规范。

常见的生产CPU的公司有Intel（英特尔公司）、AMD（超威半导体公司），这两家公司生产的CPU的架构为x86架构、x64架构，这两种架构的CPU广泛应用于它个人电脑、服务器等领域； 而ARM（安谋公司）生产的CPU的架构为ARM7架构、ARM64架构，这两种架构的CPU广泛应用于移动设备、嵌入式系统等领域，那具体什么是x86架构、x64架构、ARM7架构、ARM64架构呢？

* x86架构：x86架构是指规定了寄存器的位数为32位，总线的位数为32位，CPU可以识别x86汇编生成的机器指令，机器指令的位数为32位的一套规范
* x64架构：x64架构是指规定了寄存器的位数为64位，总线的位数为64位，CPU可以识别x64汇编生成的机器指令，机器指令的位数为64位的一套规范
* ARM7架构：ARM7架构是指规定了寄存器的位数为32位，总线的位数为32位，CPU可以识别ARM7汇编生成的机器指令，机器指令的位数为32位的一套规范
* ARM64架构：ARM64架构是指规定了寄存器的位数为64位，总线的位数为64位，CPU可以识别ARM64汇编指令指令生成的机器指令，机器指令的位数为64位的一套规范

###### 1.2 CPU位数

CPU位数其实就是指寄存器的位数、总线的位数、机器指令的位数，所以CPU位数就是由CPU架构决定的，比如x86架构和ARM7架构的CPU的位数就是32位，而x64架构和ARM64架构的CPU的位数就是64位。那32位的CPU和64位的CPU有什么区别呢？这其实就是在问32位和64位的寄存器有什么区别、32位和64位的总线有什么区别、32位和64位的机器指令有什么区别？

* 32位的寄存器能存储的数据肯定要比64位的要小，比如32位寄存器就只能把小数当成单精度浮点数来存，而64位寄存器则可以把小数当成双精度浮点数来存

* 32位的地址总线能表征的内存地址范围为32根电线全部低电平 ~ 32根电线全部高电平——即0x00000000 ~ 0xFFFFFFFF——即0 ~ 2^32，也就是说32位的地址总线能表征的内存地址个数为2^32个，而一个内存地址对应一个内存单元，一个内存单元是一个字节，所以2^32个内存地址就可以对应2^32个内存单元，加起来一共就是2^32B = 2^22KB =2^12MB = 2^2GB = 4GB，这就是我们常说的32位的CPU的寻址范围为4GB，这也是为什么以前的电脑的内存条顶多是4GB的原因，就算你给它换成8GB的内存条也没有任何帮助，因为CPU的位数决定了它无法访问4GB以外的内存。而64位的地址总线能表征的内存地址范围为64根电线全部低电平 ~ 64根电线全部高电平——即0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF——即0 ~ 2^64，也就是说64位的地址总线能表征的内存地址个数为2^64个，而一个内存地址对应一个内存单元，一个内存单元是一个字节，所以2^64个内存地址就可以对应2^64个内存单元，加起来一共就是2^64B = 2^54KB = 2^44MB = 2^34GB = 2^24TB = 33554432TB，这就是我们常说的64位的CPU的寻址范围为33554432TB，这是一个非常大的数，这也是为什么我们现在经常在64位CPU的电脑上扩展内存条的原因，它是真得能读
* 32位的机器指令是指一条机器指令会占用32位——即4个字节的内存，64位的机器指令是指一条机器指令会占用64位——即8个字节的内存，很明显32位的两条指令可以合并成64位的一条指令来存，这样在同样的时钟频率下，CPU就可以执行两倍多的机器指令了

总得来说，64位的CPU要比32位的CPU存储能力更强、寻址范围大到离谱、性能更高。

###### 1.3 不同种类的汇编

CPU架构除了决定CPU位数以外，还决定了CPU可以识别什么汇编生成的机器指令，所以针对不同的CPU架构就有不同种类的汇编，这个我们留到后面学习汇编时再说。

###### 1.4 操作系统位数和应用程序位数

操作系统其实也是一个软件，只不过是一个系统软件，很多操作系统都是用C、C++写的，而应用程序就是我们开发者自己写的应用软件了，既然都是软件，那大家就都是安装在硬盘上的，所以不存在说什么“在操作系统上安装一个应用程序”的说法，只不过操作系统这个软件有点特殊，它提供了很多能力，我们编写的应用程序或者使用的别人开发的应用程序都是通过它来让CPU执行特定的机器指令的，我们平常所说的“这个软件在Windows上能跑得起来，在macOS上就跑不起来”，这里的“能不能跑起来”指的就是应用程序能不能正常使用操作系统所提供的能力来让CPU正常工作，也就是说操作系统这个软件就像是应用软件和硬件之间的桥梁。

操作系统其实都会把特定的机器指令集内置到自己内核中，以便跟相应架构的CPU沟通，比如Windows系统可以把x86汇编指令对应的机器指令集内置到自己的内核中，以便和x86架构的CPU沟通，因为这些机器指令的位数为32位，所以这个版本的Windows系统就是32位的系统，同理Windows系统也可以把x64汇编指令对应的机器指令集内置到自己的内核中，以便和x64架构的CPU沟通，因为这些机器指令的位数为64位，所以这个版本的Windows系统就是64位的系统，换句话说操作系统的位数就是指它内置的机器指令的位数。因此我们可以得出这样的结论：如果你电脑的CPU的位数是32位的，那你就只能给它安装32位的操作系统，因为32位的CPU是读不懂64位的机器指令的；而如果你电脑的CPU的位数是64位的，那你当然能给它安装64位的操作系统，因为64位的CPU肯定能读懂64位的机器指令，此外你也能它安装32位的操作系统，因为64位的机器指令只不过是32位机器指令的扩展，64位的CPU也是能读懂32位的老机器指令的，但也可能存在兼容性问题。

应用程序的位数就是指它编译完后机器指令的位数了，这个东西是可以由我们程序员主动控制的，如果你想把你的应用程序跑在32位的操作系统上，那就把你应用程序编译成32位的就行了，如果你想把你的应用程序跑在64位的操作系统上，那就把你应用程序编译成64位的就行了，当然编译成32位的也行，但也可能存在兼容性问题。

#### 2、内存相关的知识

###### 2.1 存储单位

千米、米、分米、厘米、毫米、纳米是长度单位，它们一般用来描述长度的大小，其中米是长度单位的基本单位，所谓基本单位就是指在某个单位制下选定某个单位为基本，其它单位都由该单位推导而出。

年、月、日、时、分、秒是时间单位，它们一般用来描述时间的长短，其中秒是时间单位的基本单位。

位（b）、字节（B）、千字节（KB）、兆字节（MB）、吉字节（GB）、太字节（TB）则是存储单位，它们一般用来描述内存的存储容量，其中字节是存储单位的基本单位：

 *  1B = 8b
 * 1KB = 1024B
 * 1MB = 1024KB
 * 1GB = 1024MB
 * 1TB = 1024GB

###### 2.2 内存单元与内存地址

比方说我们电脑的内存是8GB的，它跟硬盘的大小比起来虽然差远了，但是它跟要存储的数据比起来还是非常大的，比如一个int类型的数据才占4个字节，那我们总不能把这8GB的整块内存都用来存储这一个数据吧，那怎么样才能更好地利用这8GB的内存呢？很简单，把这8GB的内存给尽可能小地分割成一个一个的内存单元，你的数据需要用多少个内存单元来存储你就拿多少，而不是像原来没分割之前把这8GB一整块全拿走，这样就不会浪费内存了，那多小算是尽可能小呢？一个内存单元4GB、分成两个？一个内存单元还是太大了！一个内存单元2GB，分成四个？一个内存单元还是太大了！一个内存单元1GB、分成八个？一个内存单元还是太大了！一个内存单元1MB、分成8 * 1024个？一个内存单元还是太大了！一个内存单元1KB、分成8 * 1024 * 2014个？一个内存单元还是太大了！一个内存单元1B、分成8 * 1024 * 1024 * 1024 = 2^3 * 2^10 * 2^10 * 2^10 = 2^33个？好像差不多了，这样一个int类型的数据就拿4个内存单元来存储，一个char类型的数据就拿一个内存单元来存储，这样就有大片的内存可以用来存储其它的数据了，好像很不错。那一个内存单元的大小还可以更小吗？还真不能了，这主要是由内存的物理结构所限制的，可看下这篇文章：[为什么内存地址是以字节为单位?](https://www.jianshu.com/p/bc8252f18ecf)，也就是说一个内存单元最小就只能是1个字节了，不能再小了，这里注意区分计算机的最小存储单位是bit，但一个内存单元的最小单位却是Byte。

ok，上面已经通过内存单元的方式解决了内存浪费的问题，那接下来的问题就是我们怎么去访问——即读取、写入——这么多的内存单元呢？很简单，我们只需要给每一个内存单元分配一个唯一编号就可以了，比如上面2^33个内存单元，我们就可以分别用数字0、1、2、......、2^33-3、2^33-2、2^33-1来作为它们的唯一编号，然后通过唯一编号就可以精准地访问对应的内存单元了，而每个内存单元的唯一编号有一个专业术语叫做内存地址，内存地址通常又是用十六进制来表示的，所以上面2^33个内存单元的内存地址就是0x0000000000000000、0x0000000000000001、0x0000000000000002、......、0xFFFFFFFFFFFFFFFD、0xFFFFFFFFFFFFFFFE、0xFFFFFFFFFFFFFFFF，我们这里为什么要用8个字节来表示一个内存地址呢？因为在64位的CPU上一个地址就是占8个字节，如果是在32位的CPU上一个地址则是占4个字节。

综上，我们就知道了其实内存是由一个一个的内存单元组成的，每个内存单元的大小为1个字节；而每个内存单元都有它的唯一编号——即内存地址，每个内存地址占8个字节；我们可以通过内存地址来精准地访问对应的内存单元。

通常，我们把连续的几个内存单元叫做内存块，把连续的几个内存块叫做内存段。

###### 2.3 内存分区

内存从高地址到低地址分为五大区：栈区 > 堆区 > 静态全局区 > 常量区 > 代码区。

* 栈区
  * 用来存储函数形参的值、函数执行体内局部变量的值、函数调用过程中一些为了维持栈平衡的值
  * 由操作系统自动管理，怎么个管理法呢？栈区是在程序运行过程中开辟和释放的；栈区就是给函数调用准备的，所以每当发生函数调用时，操作系统就会在栈区开辟一段专门的内存来供该函数使用，我们称这段内存为该函数的栈帧，函数调用完毕后，操作系统又会自动释放该函数对应的栈帧
  * 栈区是可读可写的
  * 栈区是从高地址往低地址分配的，栈内存的分配是连续的
* 堆区
  * 用来存储一些“对象”类型的数据
  * 由我们程序员手动管理，怎么个管理法呢？堆区是在程序运行过程中开辟和释放的；通过malloc、calloc、realloc等函数开辟堆内存，通过free等函数释放堆内存
  * 堆区是可读可写的
  * 堆区是从低地址往高地址分配的，堆内存的分配是不连续的
* 静态全局区
  * 用来存储存储静态变量的值和全局变量的值，静态变量是指用static修饰的变量，全局变量是指在函数外面定义的变量
  * 由操作系统自动管理，怎么个管理法呢？应用程序一载入到内存，静态全局区就开辟好了；操作系统就会把可执行文件静态全局区的内容给搬过来，静态全局区的大小也就固定了；直到应用程序退出，静态全局区才会被释放
  * 静态全局区是可读可写的
* 常量区
  * 用来存储字符串字面常量
  * 由操作系统自动管理，怎么个管理法呢？应用程序一载入到内存，常量区就开辟好了；操作系统就会把可执行文件常量区的内容给搬过来，常量区的大小也就固定了；直到应用程序退出，常量区才会被释放
  * 常量区是只读的，不允许被修改
* 代码区
  * 用来存储函数、变量名和函数名对应的符号、结构体类型名和枚举类型名对应的符号等一大堆东西
  * 由操作系统自动管理，怎么个管理法呢？应用程序一载入到内存，代码区就开辟好了；操作系统就会把可执行文件代码区的内容给搬过来，代码区的大小也就固定了；直到应用程序退出，代码区才会被释放
  * 代码区是只读的，不允许被修改

###### 2.4 大小端模式

大小端模式取决于CPU架构，现在比较常见的是小端模式，大小端模式决定了多字节数据的字节存储顺序，但凡是多字节数据、不管你是什么数据，整型也好、浮点型也好、字符串也好、甚至是图片、音频、视频的二进制数据也好，都遵循大小端模式：

* 大端模式（Big-endian）：高低低高，即数据的高字节存进内存的低字节、数据的低字节存进内存的高字节
* 小端模式（Little-endian）：高高低低，即数据的高字节存进内存的高字节、数据的低字节存进内存的低字节

###### 2.5 内存的特性

* 在哪个内存分区
* 首地址是什么
* 多大或者以什么作为结束标识

#### 3、硬盘相关的知识

暂无。

#### 4、补充：堆内存的开辟和释放

###### 4.1 malloc函数（memory allocation内存分配）和free函数

> void* malloc(unsigned int size);

* malloc函数用来开辟size个字节大小的堆内存，注意开辟完后这块堆内存里存放的还是以前别人使用时候的垃圾数据
* 并把这段堆内存的首地址返回，之所以返回void\*是代表这段堆内存可以存储任意类型的数据，你用什么指针接收这个首地址就代表你想存什么类型的数据在这块堆内存里
* 如果申请失败（比如堆区公共才几个G，你却要开辟1T的内存）则返回空指针NULL，所以在使用这块内存之前一定要判空

> void free(void *);

* free函数用来释放某块堆内存（不要用它来释放其它内存分区的内存，会出运行时错误），我们只需要把想释放的内存的首地址传递给它就行了，因为free函数总是跟malloc函数成对出现，所以它是知道应该释放多大的内存的，因为malloc函数哪里指定了开辟多大内存嘛
* free如果接收了一个空指针NULL，那它就什么都不做

**注意：我们用malloc函数开辟的堆内存，在使用完后一定要顶用free函数释放掉，避免内存泄漏，同时在free函数后面要手动把指针及时置为NULL，避免野指针。**

```c
#include <stdlib.h> // malloc、calloc、realloc、free函数所在的头文件

void test() {
    // 在栈区开辟4个字节的内存，把10存进这块内存里
    int i = 10;
    // 读取这块内存里的数据
    printf("栈内存：%d\n", i); // 栈内存：10
    
    // 在堆区开辟4个字节的内存，我们用整型指针来接收这块内存的首地址，代表我们想往这块内存里存储整型
    // 这里出现了指针，就一定有两块内存，局部变量p本身所对应的栈内存和4个字节的堆内存
    // 对于那块堆内存，我们只能拿到它的地址————即存储在局部变量p所对应的栈内存里，所以要操作那块堆内存就只能通过指针变量来操作了
    int *p = malloc(4);
    if (p == NULL) {
        printf("开辟堆内存失败\n");
        return;
    }
    // 我们知道拿到p就是拿到了那块堆内存的地址，拿到*p就是拿到那块堆内存的值
    *p = 10;
    // 读取这块内存里的数据
    printf("堆内存：%d\n", *p); // 堆内存：10
    
    // 释放堆内存
    free(p);
    // free函数调用后堆内存是释放了，但指针变量p还是指向那段堆内存的，也就是说是个野指针，所以要把指针赋值为NULL避免野指针
    p = NULL;
}
```

###### 4.2 calloc函数（cleared memory allocation清空内存分配）和free函数

> void* calloc(unsigned int count, unsigned int size);

* calloc函数用来开辟count个元素、一个元素占size个字节大小的堆内存，注意开辟完后这块堆内存里会全部被初始化为0（calloc在开辟内存时根本不知道外界会用来存储什么，所以它内部永远是把这段堆内存初始化成0的，跟你外界用什么接收首地址无关——还没走到接收那一步呢人家就已经开辟并初始化完了，所以就算你外界想拿这段堆内存存放结构体，人家calloc照样是把那段堆内存全部初始化为0）
* calloc函数和malloc函数的区别就是开辟完内存后有没有初始化那块内存，所以是用malloc还是calloc就是看你想不想在开辟好那段堆内存时就是初始化好的，不过初始化好好像也没多大用，只是为了避免垃圾数据嘛，这个完全可以由我们自己来把控，所以我们完全可以把这两个函数看成是一样的，随便你用哪个都行

```c
#include <stdlib.h> // malloc、calloc、realloc、free函数所在的头文件

void test1() {
    int i = 10;
    printf("栈内存：%d\n", i); // 栈内存：10
    
    int *p = calloc(1, 4);
    if (p == NULL) {
        printf("开辟堆内存失败\n");
        return;
    }
    *p = 10;
    printf("堆内存：%d\n", *p); // 堆内存：10
    
    free(p);
    p = NULL;
}
```

###### 4.3 realloc函数（re-allocation重新分配）和free函数

> void* realloc(void *ptr, unsigned int size);

比如说我们之前通过malloc或calloc或realloc函数开辟了一段堆内存，但是后来对那段堆内存不太满意，比如想把它变大或者变小些，那就可以使用realloc函数，不过realloc函数的内部实现会针对两种情况：

* ptr指向的那块就堆内存的后面（也就是高字节）如果有足够的空闲内存————即大于等于size - ptr指向的那块旧堆内存的大小这么大，那realloc函数就会直接在ptr指向的那块就堆内存的后面续上一段内存凑够size个字节的大小，然后还是把ptr给返回
* ptr指向的那块就堆内存的后面（也就是高字节）如果被别人开辟使用了，也就是说留下的空闲的堆内存不够size - ptr指向的那块就堆内存的大小这么大了，realloc函数用来开辟一段size个字节大小的新的堆内存，并且会把以ptr为首地址、指定大小（因为ptr必须得是malloc或calloc或realloc函数开辟的，所以大小是肯定能知道的）的旧堆内存里内容拷贝到新堆内存里，并free掉旧堆内存，然后返回新堆内存的首地址，之所以要用realloc就是想保证多次开辟内存里存储的数据是连续存储的，不丢失以前存储的数据，典型的场景就是数组的扩容和缩容

```c
#include <stdlib.h> // malloc、calloc、realloc、free函数所在的头文件

void test2() {
    int *p = malloc(4);
    if (p == NULL) {
        printf("开辟堆内存失败\n");
        return;
    }
    *p = 10;
    printf("堆内存：%d\n", *p); // 堆内存：10
    
    // 扩容：再开辟一个字节的内存，存储20
    // 注意不要拿p来接收，而总是拿一个新指针变量来接受，因为如果重新开辟堆内存失败，那连p之前的内存都找不到了
    // 等确保开辟成功后我们可以把p1赋值给p，以便都是用p来操作那一堆数据，代码上下文看起来更连贯，当然你用p1
    // 去操作内存肯定也没问题，只是代码感觉从realloc的地方分成了上下两部分，这样会给我们好像不是扩容的感觉
    // 而是完全的一段新内存
    int *p1 = realloc(p, 1);
    if (p1 == NULL) {
        printf("重新开辟堆内存失败\n");
        return;
    } else {
        p = p1;
    }
    printf("p = %p\n", p); // 0x600000008040
    printf("p1 = %p\n", p1); // 0x600000008040，跟p是一样的，可见是第一种情况
    *(p + 1) = 20;
    printf("堆内存：%d\n", *(p + 1)); // 堆内存：20

    free(p);
    p = NULL;
}
```

###### 4.4 为什么要用堆区

```c
#include <stdlib.h> // malloc、calloc、realloc、free函数所在的头文件

// 总共就那么五大内存分区，代码区、常量区、静态全局区的内存在编译之后就不能改变了，只有栈内存和堆内存是在程序运行时开辟和释放的
// 而栈内存是由系统自动管理的，生命周期一般很短，而堆内存则是由我们程序员自己管理的，生命周期完全可以掌控在我们手里，比如下面的例子：
// 这个函数是没问题的，虽然test3在执行完毕后，age对应的栈内存就释放了，但是返回值10这个数会直接存放到寄存器里，所以是可以正常拿到的
int test3() {
    int age = 10;
    return age;
}

// 这个函数就有问题了，因为test4在执行完毕后，age对应的栈内存就释放了，我们是把已经释放了的栈内存的地址存放到寄存器里，那后续再用这个地址访问就是野指针访问了
int* test4() {
    int age = 10;
    return &age;
}

// 而堆内存就可以很好的解决这个问题，也就是说函数的返回值可以是值、也可以是地址，但如果返回地址时，那就绝对不能返回栈内存的地址，这会导致野指针，我们可以返回其它四个分区的地址，比如我们就可以返回堆区的地址
// 但需要注意的是，如果返回的是堆区的地址，因为函数内部是没有释放堆内存的，外界一定要记得释放一下，否则就会导致内存泄漏
int* test5() {
    int *ptr = malloc(4);
    *ptr = 10;
    return ptr;
}

// 再举个返回常量区的例子：
// 这个不用说是返回栈区的地址，绝对会导致野指针
char* test6() {
    char str[] = "Hello World!";
    return str;
}

// 而这个就是ok的，因为返回的是常量区的地址
char* test7() {
    char *str = "Hello World!";
    return str;
}

int main() {
    printf("%d\n", test3()); // 10
  
    printf("%d\n", *test4()); // 用野指针访问到的是垃圾数据
  
    int *ptr = test5();
    printf("%d\n", *ptr); // 10
    free(ptr);
    ptr = NULL;
  
    printf("%s\n", test6()); // 用野指针访问到的是垃圾数据
  
    printf("%s\n", test7()); // Hello World!
    
    return 0;
}
```

