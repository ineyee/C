## 三、汇编

我们这里学习一些简单的汇编，目的是帮助我们了解编程语言的本质，也就是说帮助我们知道我们编写的高级语言代码到底是在干什么，所以也不会学得特别深。

#### 1、不同种类和不同书写格式的汇编

不同架构的CPU只能识别特定的汇编，因此针对不同架构的CPU存在不同种类的汇编，而同一种类的汇编又有不同的书写格式：

|  CPU架构  | 汇编种类  |      汇编书写格式       |                   对应设备、CPU、操作系统                    |
| :-------: | :-------: | :---------------------: | :----------------------------------------------------------: |
|  x86架构  |  x86汇编  | Intel格式<br />AT&T格式 | Intel或AMD生产的32位CPU、Windows电脑<br />Intel或AMD生产的32位CPU、macOS电脑 |
|  x64架构  |  x64汇编  | Intel格式<br />AT&T格式 | Intel或AMD生产的64位CPU、Windows电脑<br />Intel或AMD生产的64位CPU、macOS电脑 |
| ARM7架构  | ARM7汇编  |  GNU格式<br />AT&T格式  | ARM生产的32位CPU、iOS/Android手机<br />ARM生产的32位CPU、macOS/Windows电脑 |
| ARM64架构 | ARM64汇编 |  GNU格式<br />AT&T格式  | ARM生产的64位CPU、iOS/Android手机<br />ARM生产的64位CPU、macOS/Windows电脑 |

虽然汇编有不同的种类和不同的书写格式，但其实也大同小异，学会了其中一个种类和书写格式，其它的也都是以此类推的事，总之学汇编其实就学一下常见的寄存器、常见的汇编指令、函数栈帧的创建和销毁就差不多了。

这一次学习我们用的是ARM64架构的iPhone真机，所以对应的汇编就是ARM64汇编，书写格式就是GNU格式。

#### 2、常见的寄存器

* 通用寄存器
  * w0 ~ w28：29个32位的寄存器，w是“word”的缩写，一个“word”就是4个字节——32位，因此见到w开头的就是32位的寄存器
  * x0 ~ x28：29个64位的寄存器，x是“extended”的缩写，因此见到x开头的就是64位的寄存器
  * 其实w0 ~ w28和x0 ~ x28共用的是一个寄存器，也就是说x0 ~ x28寄存器的低32位会被当作w0 ~ w28寄存器来使用，这是为了64位的CPU兼容32位的汇编指令而设计的
  * 其中w0 ~ w7或x0 ~ x7一般用来存储函数形参的值——立即数，即函数形参的值会先存进寄存器，然后再存进栈内存，因为立即数不能直接存进内存，必须经由寄存器中转；而w0或x0还用来存储函数的返回值，也就是说我们只能把返回值存储到w0或x0里，不能把返回值存储到其它寄存器里，因为CPU它只会去w0或x0里去读取数据并把这个数据认定为是函数的返回值，也就是说函数的ret指令执行完后，CPU如果发现函数外界有其它东西在接收函数的返回值，那CPU就会从w0或x0里把这个数据读取出来赋值给接收的那个东西
  * 其中w8 ~ w28或x8 ~ x27一般用来存储其它的立即数、内存地址
* 程序状态寄存器
  * cpsr（Current Program Status Register）：如果cpsr的最高一位是1那就代表有两个操作数相减是个负数，如果是0就代表两者相减是0或正数、此时又得去看cpsr的最高第二位，如果是1那就代表有两个操作数相减是0、如果是0那就代表有两个操作数相减是正数
* 零寄存器：里面存储的就是0这个数值，一般用来给一些变量赋初始值如整型的0、指针类型的NULL等，这个寄存器是不允许我们读写的

  * wzr：32位的零寄存器，zero register

  * xzr：64位的零寄存器，zero register
* 程序计数器：存储着CPU当前正在执行的机器指令的内存地址

  * pc：Program Counter
* 链接寄存器——即x30寄存器：当发生函数调用时——即出现bl指令时，CPU会先把下一条指令的内存地址存进该寄存器，然后CPU一执行到ret指令就会去这个寄存器里读取并跳转到这个地址去执行指令，而执行b指令时，CPU不会把下一条指令的地址存进链接寄存器，所以如果你用b指令跳进一个函数的话，执行到函数的最后一条指令ret，CPU去读取lr里的值可能就读取的是一个垃圾地址，导致程序瞎跳到一个位置去执行指令

  * lr（Link Register）
* 栈指针寄存器

  * sp（Stack Pointer）：存储着当前函数的栈帧的栈顶指针
  * fp（Frame Pointer）——即x29寄存器：存储着当前函数的栈帧的栈底指针，frame就是帧嘛
  * 函数一开始调用时，sp和fp是指向同一个地址的


#### 3、常见的汇编指令

**汇编里的操作数分为立即数、寄存器和内存地址**，立即数就是指能直接写出来的东西，立即数一般都是#开头，比如整数立即数#10、小数立即数#3.14、字符立即数#'A'、布尔立即数#true，当然立即数也有可能是以它们的十六进制存在的，看到时不要惊讶；寄存器就是上面那些东西；而内存地址可能会以三种形式存在：

* 立即寻址：0x11223344aabbccdd，直接就是一个地址
* 间接寻址：[寄存器]，[]代表把寄存器里存储的值当作一个地址来看待、并且去访问这个地址所对应内存里的值
* 基址变址寻址：[寄存器, 操作数]，[]代表取把寄存器里存储的值当作一个地址来看待、然后把这个地址 + 操作数个字节的大小得到一个新的地址、并且去访问这个新地址所对应内存里的值

**汇编指令只能操作操作数**，常见的汇编指令有：

* `ret`：return的缩写，用来返回到函数调用前的下一条机器指令去执行
* `mov 目的寄存器, 操作数`：move的缩写，把操作数存储到目的寄存器里
* `add 目的寄存器, 操作数1, 操作数2`：把操作数1和操作数2相加，并存储到目的寄存器里
* `sub 目的寄存器, 操作数1, 操作数2`：把操作数1和操作数2相减，并存储到目的寄存器里
* `cmp 操作数1, 操作数2`：compare的缩写，比较两个操作数，怎么个比较法呢？就是把两个操作数相减，然后把相减的结果存储到cpsr寄存器里，经常跟b指令或bl指令联合使用
* `b 目标内存地址`：branch的缩写，即分岔、岔开的意思，无条件跳转到目标内存地址执行机器指令，无法返回
* `beq 目标地址`：这是带条件的b指令，eq是equal的缩写，这条指令会先去cpsr寄存器读取cmp指令的结果，然后如果相等才跳转到目标内存地址执行机器指令
* `bne 目标地址`：这是带条件的b指令，ne是not equal的缩写，这条指令会先去cpsr寄存器读取cmp指令的结果，然后如果不相等才跳转到目标内存地址执行机器指令
* `bgt 目标地址`：这是带条件的b指令，gt是great than的缩写，这条指令会先去cpsr寄存器读取cmp指令的结果，然后如果大于才跳转到目标内存地址执行机器指令
* `blt 目标地址`：这是带条件的b指令，lt是less than的缩写，这条指令会先去cpsr寄存器读取cmp指令的结果，然后如果小于才跳转到目标内存地址执行机器指令
* `bge 目标地址`：这是带条件的b指令，ne是great than or equal的缩写，这条指令会先去cpsr寄存器读取cmp指令的结果，然后如果大于等于才跳转到目标内存地址执行机器指令
* `ble 目标地址`：这是带条件的b指令，ne是less than or equal的缩写，这条指令会先去cpsr寄存器读取cmp指令的结果，然后如果小于等于才跳转到目标内存地址执行机器指令
* `bl 内存地址`：branch with link的缩写，表示带链接的跳转语句，它跟b指令都是跳转到某个内存地址去执行机器指令，但是它俩的区别是b指令只负责跳不负责返回到跳转之前的地方，而bl不仅负责跳还会返回到跳转之前的地方，bl指令就相当于其它汇编里的call指令，专门用来调用函数的，也就是说函数的ret指令只有在被bl指令跳过来时才会生效、能跳回去，如果是b指令跳过到某个函数的，那ret指令是不生效的、不会跳回去的，b指令就相当于其它汇编里的jmp指令
* `带条件的bl指令`：bl也有带条件的指令，意思就是满足某些条件时跳去执行某个函数，而带条件的b指令意思只是满足某些条件时就执行某些代码——这些代码并非某个函数
* load，从内存中读取数据（数据：值或地址）

  * `ldr 寄存器, 内存地址`：ld是load的缩写，r是register的缩写，把首地址为“内存地址”的那块内存里的数据读取出来，存储到寄存器里
  * `ldur 寄存器, 内存地址`：ld是load的缩写，r是register的缩写，u是unsigned offset的缩写，把首地址为“内存地址”的那块内存里的数据读取出来，存储到寄存器里。ldur和ldr的区别是ldur这个指令一般只用于内存地址以基址变址寻址的方式存在时、且操作数是负数的情况，功能跟ldr是一样的，其它的都是用ldr
  * `ldp 寄存器1, 寄存器2, 内存地址`：ld是load的缩写，p是pair的缩写，把首地址为“内存地址”的那块内存里的数据读取出来，存储到寄存器1里，接着把首地址为“内存地址 + 8个字节”的那块内存里的数据读取出来，存储到寄存器2里，至于是加几个字节得看你是拿多大的寄存器1来接收数据的，如果寄存器1是32位的那就加4个字节，如果寄存器1是64位的那就加8个字节，因为读了一对数据到一对寄存器里，所以指令名里叫pair
* store，往内存中写入数据（数据：值或地址）

  * `str 寄存器, 内存地址`：st是store的缩写，r是register的缩写，把寄存器里的值写入到首地址为“内存地址”的那块内存里
  * `stur`：同理
  * `stp和stup`：同理

**mov等指令的操作数只能是立即数和寄存器，而load、store等指令的操作数可以是寄存器、内存地址，也就是说立即数 <==> 寄存器 <==> 内存（某块内存地址对应的内存），我们不能直接把立即数写入到内存中，也不能直接从内存中读取立即数，中间必须有寄存器来倒腾一下，为什么呢？因为假设有个数值10，我们如果能直接往内存里存，那谁知道用覆盖内存的几个字节来存储这个10呢？不知道啊，所以只有中间经过寄存器转一下才知道，如果用的w寄存器那就是内存中占4个字节来存储10，如果用的是x寄存器那就是内存中占8个字节来存储10。**

#### 4、函数栈帧的创建和销毁

假设我们有一个函数如下：

```c
int test(int i1, int i2) {
    int i3 = 30;
    int i4 = 40;
    return i1 + i2 + i3 + i4;
}
```

编译之后该函数对应的汇编为：

```c
_test:
// 把sp寄存器里存储的值 - 16，然后再赋值给sp寄存器
sub	sp, sp, #16
  
// 把w0寄存器里存储的4个字节大小的值，存储到sp寄存器里存储的值 + 12这个内存地址，即把函数参数i1的值存储到栈内存中（函数参数i1的值即立即数无法直接放入到内存中，所以总是先放到寄存器里，然后再放入到内存中）
str	w0, [sp, #12]
// 把w0寄存器里存储的4个字节大小的值，存储到sp寄存器里存储的值 + 8这个内存地址，即把函数参数i2的值存储到栈内存中
str	w1, [sp, #8]
// 把30这个立即数移动到w8寄存器里（立即数无法直接放入到内存中，所以总是先放到寄存器里，然后再放入到内存中）
mov	w8, #30
// 把w8寄存器里存储的4个字节大小的值，存储到sp寄存器里存储的值 + 4这个内存地址，即把局部变量i3的值存储到栈内存中
str	w8, [sp, #4]
// 把40这个立即数移动到w8寄存器里
mov	w8, #40
// 把w8寄存器里存储的4个字节大小的值，存储到sp寄存器里存储的值这个内存地址，即把局部变量i4的值存储到栈内存中
str	w8, [sp]
    
// 把第一个参数的值读取出来，存储到w8寄存器里
ldr	w8, [sp, #12]
// 把第二个参数的值读取出来，存储到w9寄存器里
ldr	w9, [sp, #8]
// 把两个参数的值加起来，存储到w8寄存器里，此时w8寄存器里存储的是两个参数的和
add	w8, w8, w9
// 把第一个局部变量的值读取出来，存储到w9寄存器里
ldr	w9, [sp, #4]
// 把两个参数的和跟第一个局部变量的值加起来，存储到w8寄存器里，此时w8寄存器里存储的是两个参数的和 + 第一个局部变量的值
add	w8, w8, w9
// 把第二个局部变量的值读取出来，存储到w9寄存器里
ldr	w9, [sp]
// 把两个参数的和 + 第一个局部变量的值跟第二个局部变量的值加起来，存储到w0寄存器里——作为函数的返回值用
add	w0, w8, w9
  
// 把sp寄存器里存储的值 + 16，然后再赋值给sp寄存器
add	sp, sp, #16

// 返回
ret
```

那么当该函数被调用时，它的栈帧是如何创建销毁的呢？

* 假设该函数在调用前，sp指针和fp指针都指向0x1010这个内存地址
<img width="271" alt="image-20230430083904322-2815149" src="https://user-images.githubusercontent.com/16254545/236132008-f6e8a752-3d00-4ba9-8658-c1a5fda426c7.png">

* 该函数在调用时，第一条指令是“sub	sp, sp, #16”，也就是说让sp指针指向0x1010 - 16 = 0x1000这个地址，这样[sp, fp)即[0x1000, 0x1010)这16个字节的栈内存就是该函数的栈帧了，专门供该函数的调用开销
<img width="271" alt="image-20230430084010724" src="https://user-images.githubusercontent.com/16254545/236132374-64084c66-251b-4503-b7bb-a680aae13058.png">

* 第2 ~ 14条指令执行完后，该函数的栈帧为：
<img width="272" alt="image-20230430085403690" src="https://user-images.githubusercontent.com/16254545/236132422-2ddd83f8-cab1-4093-aea6-5529a0d584a0.png">

* 执行“add	sp, sp, #16”指令，也就是说让sp指针指向0x1000 + 16 = 0x1010这个地址，这样[sp, fp)即[0x1010, 0x1010)这0个字节的栈内存就是该函数的栈帧了，也就是说销毁了该函数的栈帧，sp和fp指针跟函数调用前指向的内存地址是一样的，这就是所谓的栈平衡，这条指令很重要，如果没有的话就会出现栈内存泄漏，每产生一次函数调用，sp指针都会往低地址移动一部分，最终会导致栈内存溢出
<img width="272" alt="image-20230430090442256" src="https://user-images.githubusercontent.com/16254545/236131947-9cebce0c-8a93-49fd-98d7-2282b740df67.png">

* 执行ret指令就会跳到函数的下一条指令去执行



