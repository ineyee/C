## 二、应用程序的构建与运行

#### 1、应用程序的构建

应用程序的构建（Build）是指把我们写的所有的代码生成可执行文件的过程，包含编译和链接两个阶段。

###### 1.1 编译

编译（Compile）是指把我们写的所有的代码生成目标文件的过程，又包含预处理、编译、汇编三个小步骤，编译操作是由编译器（Compiler）完成的。

main.c、test.c这样的文件被称为源文件，源文件里存放的就是我们写的所有的代码，main.h、test.h这样的文件被称为头文件，头文件会被合并到源文件里，这个下面会说到。

源文件经过编译后被称为目标文件main.o、test.o，目标文件里存放的就是0101这样的二进制数据了，**目标文件这种特定格式的文件在存储数据时已经分为三个分区了：静态全局区、常量区、代码区。**

* 预处理

**预处理是指我们写的注释会在预处理阶段被全部去掉，所以说增加和删除注释不会影响可执行文件的大小；导入头文件的本质其实就是把头文件里的东西给完整地拷贝一份过来，导入头文件的代码在预处理过后就不存在了；宏定义的本质其实就是完全的替换，宏定义的代码在预处理过后就不存在了；条件编译就是指预处理阶段根据情况决定将来哪些代码要参与编译、哪些代码不要参与编译，比如下面的main.h里如果没有条件编译的代码，那“int i = 10;”肯定会被拷贝两份过来，条件编译的代码在预处理过后就不存在了；预处理符号的本质其实就是完全的替换，预处理符号的代码在预处理过后就不存在了**，预处理某个源文件的指令：

> **xcrun -sdk iphoneos clang -arch arm64 源文件名.c -E -o 源文件名.i**

假设我们有一个main.h和一个main.c文件如下：

```c
#ifndef main_h
#define main_h

int i = 10;

#endif /* main_h */
```

```c
#pragma mark - 1、注释

// 我是一个单行注释

/*
 我是一个多行注释
 我是一个多行注释
 我是一个多行注释
 */


#pragma mark - 2、导入头文件

#include "main.h" // 第一次导入
#include "main.h" // 第二次导入


#pragma mark - 3、宏定义

#define MAX 100


#pragma mark - 4、条件编译

// #ifndef 文件名_h
// #define 文件名_h
//
// 我们的代码...
//
// #endif /* 文件名_h */

// 上面这个固定写法的条件编译主要写在头文件里，用来防止头文件的重复导入和循环导入，试想一下：
// 第一次导入某个头文件时，“#ifndef 文件名_h”肯定是成立的，于是就执行“#define 文件名_h”，然后再执行“我们的代码...”，最后“#endif”，这就意味着这个头文件里是有东西的
// 第二次导入这个头文件时，“#ifndef 文件名_h”肯定就不成立了，后面的东西就都不执行了，这就意味着这个头文件里是空的


#pragma mark - 5、预处理符号

// __FILE__：当前文件
// __LINE__：当前行数

int main() {
    int max = MAX;
    
    char *file = __FILE__;
    int line = __LINE__;

    return 0;
}
```

预处理之后对应的main.i文件为：

```c
int i = 10;

int main() {
    int max = 100;

    char *file = "main.c";
    int line = 46;

    return 0;
}
```

* 编译

编译是指把高级语言变成汇编，编译某个源文件的指令为：

> **xcrun -sdk iphoneos clang -arch arm64 源文件名.c -S -o 源文件名.s**

假设我们有一个main.c文件如下：

```c
// 全局变量
int i = 10;

// 静态全局变量
static int i1 = 20;

// 作用域是整个项目的函数
void test() {}

// 作用域是仅当前源文件的函数
static void test1() {}
```

编译之后对应的main.s文件为：

```assembly
// .section：表明下面符号的值要存储在静态全局区————__data（！！！特别注意！！！除了符号的值——立即数——之外的所有东西，包括.section、__data、.globl、.int这种声明符号，_i、_i1这种变量对应的符号，它们全都存储在代码区，它们其实就是机器指令）
.section __data
// .globl：表明_i是公开的、作用域是整个项目；_i1是私有的，作用域是仅当前源文件
.globl _i

// _i是全局变量i对应的符号，.int代表分配4个字节的内存空间，10代表内存空间里要存储什么
_i:
.int    10

// _i1是全局变量i1对应的符号，.int代表分配4个字节的内存空间，20代表内存空间里要存储什么
_i1:
.int    20

// .section：表明下面符号的值要存储在代码区————__text（刚好符号的值是一堆代码，因此跟其它东西一样也存储在代码区）
.section __text
// .globl，表明_test是公开的，作用域是整个项目；_test1是私有的，作用域是仅当前源文件
.globl _test

// _test是test函数对应的符号，函数的开始标识是符号加冒号
_test:

	// 函数的结束标识是ret指令
	ret

// _test1是test1函数对应的符号，函数的开始标识是符号加冒号
_test1:

	// 函数的结束标识是ret指令
	ret
```

* 汇编

汇编是指把汇编变成机器指令，汇编某个源文件的指令为：

> **xcrun -sdk iphoneos clang -arch arm64 源文件名.c -c -o 源文件名.o**

假设我们有一个main.c文件如下：

```c
// 全局变量
int i = 10;

// 静态全局变量
static int i1 = 20;

// 作用域是整个项目的函数
void test() {}

// 作用域是仅当前源文件的函数
static void test1() {}

int main() {
    // 局部变量
    int i2 = 30;

    // 静态局部变量
    static int i3 = 40;

    return 0;
}
```

汇编之后对应的main.o文件为：

```assembly
CF FA ED FE 0C 00 00 01 00 00 00 00 01 00 00 00 04 00 00 00 B8 01 00 00 00 20 00 00 00 00 00 00 19 00 00 00 38 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 68 00 00 00 00 00 00 00 D8 01 00 00 00 00 00 00 68 00 00 00 00 00 00 00 07 00 00 00 07 00 00 00 03 00 00 00 00 00 00 00 5F 5F 74 65 78 74 00 00 00 00 00 00 00 00 00 00 5F 5F 54 45 58 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 00 00 00 00 00 00 00 D8 01 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 04 00 80 00 00 00 00 00 00 00 00 00 00 00 00 5F 5F 64 61 74 61 00 00 00 00 00 00 00 00 00 00 5F 5F 44 41 54 41 00 00 00 00 00 00 00 00 00 00 20 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 F8 01 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 5F 5F 63 6F 6D 70 61 63 74 5F 75 6E 77 69 6E 64 5F 5F 4C 44 00 00 00 00 00 00 00 00 00 00 00 00 28 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 00 02 00 00 03 00 00 00 40 02 00 00 02 00 00 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 32 00 00 00 18 00 00 00 02 00 00 00 00 02 10 00 00 02 10 00 00 00 00 00 02 00 00 00 18 00 00 00 50 02 00 00 07 00 00 00 C0 02 00 00 30 00 00 00 0B 00 00 00 50 00 00 00 00 00 00 00 04 00 00 00 04 00 00 00 03 00 00 00 07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 03 5F D6 FF 43 00 D1 00 00 80 52 FF 0F 00 B9 C8 03 80 52 E8 0B 00 B9 FF 43 00 91 C0 03 5F D6 0A 00 00 00 28 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 1C 00 00 00 00 10 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 00 00 00 01 00 00 06 00 00 00 00 01 00 00 06 25 00 00 00 0E 01 00 00 00 00 00 00 00 00 00 00 1F 00 00 00 0E 02 00 00 20 00 00 00 00 00 00 00 10 00 00 00 0E 02 00 00 24 00 00 00 00 00 00 00 19 00 00 00 0E 03 00 00 28 00 00 00 00 00 00 00 0D 00 00 00 0F 02 00 00 20 00 00 00 00 00 00 00 07 00 00 00 0F 01 00 00 04 00 00 00 00 00 00 00 01 00 00 00 0F 01 00 00 00 00 00 00 00 00 00 00 00 5F 74 65 73 74 00 5F 6D 61 69 6E 00 5F 69 00 5F 6D 61 69 6E 2E 69 33 00 6C 74 6D 70 32 00 6C 74 6D 70 31 00 6C 74 6D 70 30 00 00 00 00 00 00
```

**总结：我们所编写的每一个源文件在编译后都会输出一个对应的目标文件，编译结束后源文件A里静态变量和全局变量的值就会存储到目标文件A里的静态全局区，源文件A里的字符串常量就会存储到目标文件A里的常量区，源文件A里的机器指令就会存储到目标文件A里的代码区，源文件B同样如此，源文件C同样如此......**

###### 1.2 链接

链接（Link）是指把所有的目标文件和静态库——静态库就是很多目标文件的集合——合并生成可执行文件的过程，链接操作是由链接器（Linker）完成的，一般来说编译器里面已经内置了链接器。

所有的目标文件和静态库经过链接后被称为可执行文件，Windows可执行文件的扩展名是.exe，macOS可执行文件的扩展名是.app，可执行文件里存放的必然也是0101这样的二进制数据，而且**可执行文件这种特定格式的文件在存储数据时必然也已经分为三个分区了：静态全局区、常量区、代码区**，其实所有的目标文件和静态库链接的过程中就在把每个目标文件的静态全局区合并到可执行文件的静态全局区、每个目标文件的常量区合并到可执行文件的常量区、每个目标文件的代码区合并到可执行文件的代码区。

#### 2、应用程序的运行

应用程序的运行（Run）是指把可执行文件从硬盘载入到内存中给跑起来。

* 我们编写的代码在编译之后就变成了可执行文件，可执行文件如果没有被双击，那它就是存储在硬盘上的
* 而当我们双击可执行文件时，操作系统就会把可执行文件从硬盘载入到内存中，首先做的就是把可执行文件静态全局区、常量区、代码区的东西给搬到内存的静态全局区、常量区、代码区里，然后就是CPU一条一条地执行代码区的机器指令了，程序在运行过程中可能会动态地开辟和释放内存的栈区和堆区，也就是说一个应用程序在非运行态时对应的是可执行文件的三大内存分区，在运行态时对应的是内存的五大内存分区。
