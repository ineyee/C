## 五、变量和常量

#### 1、变量

###### 1.1 变量是什么

**变量是指第一次赋值后还能再次赋值的量，它由存储类型、数据类型、变量名、变量的初始值四大部分组成：**

> **存储类型 数据类型 变量名 = 变量的初始值;**

* **存储类型：static、auto、extern，用来表明变量所对应的内存在什么内存分区**
* **数据类型：char、int、double、bool等，用来表明变量所对应的内存有多大或者以什么作为结束标识，直白地说就是用来存储什么数据类型的数据**
* **变量名：拿到变量名就是拿到了变量所对应的内存里的值，拿到&变量名就是拿到了变量所对应的内存的地址**
* **变量的初始值：就是存储在变量所对应的内存里的值**

###### 1.2 变量的声明

```c
// 数据类型 变量名;
int i;
```

###### 1.3 变量的赋值

```c
// 变量名 = 值;
i = 10;
```

###### 1.4 变量的读取

```c
// 拿到变量名就是拿到了变量所对应的内存里的值
printf("%d\n", i);
```

###### 1.5 变量的初始化

变量的第一次赋值叫做初始化，第一次之外的赋值就是普通赋值。

```c
int i;
i = 10; // 初始化
i = 20; // 普通赋值
```

###### 1.6 变量的声明及初始化

**变量在未被初始化之前，它里面存储的值是以前使用过的垃圾值，因此变量在使用之前必须初始化，避免因为垃圾值带来未知的错误（尽管有的编译器会自动帮我们初始化一个默认值，但还是建议手动初始化，现在很多语言在编译层面已经要求我们必须手动初始化变量，最好就是在声明变量的时候就进行初始化，如果这个阶段实在不行、那就延迟初始化、但作为开发者你一定要保证这个变量在使用之前被初始化掉）**

```c
int i;
printf("%d\n", i); // 这种写法是错误的，i的值可能是0也可能是一个垃圾值
```

* 变量的声明及初始化

```c
int i = 10;
```

* 变量的声明及延迟初始化

```c
int i;
i = 10;
printf("%d\n", i);
```

###### 1.7 变量的本质

变量其实是高级语言里才有的概念，为的就是方便我们开发者通过变量来操作内存。汇编里没有变量的概念，就是在通过指令操作立即数、寄存器和内存。**高级语言里的变量其实就对应汇编里的内存。**

**因此变量的本质就是一块内存，操作变量就是在操作内存**，比如声明一个变量的本质就是在开辟一块内存，初始化一个变量的本质就是在第一次往这块内存里写数据，给一个变量赋值的本质就是在修改这块内存里的数据，读取一个变量的值的本质就是在把数据从这块内存里给读出来，获取一个变量的地址的本质就是在获取这块内存的首地址。

#### 2、常量

###### 2.1 常量是什么

**常量是指第一次赋值后不能再次赋值的量。**

###### 2.2 常量的分类

* 字面常量

字面常量是指我们能直接写出来的东西，比如字符类型字面常量'A'，整型字面常量10，浮点型字面常量3.14，布尔类型字面常量true和false，字符串类型字面常量"ABC"。

```c
#include <stdio.h>

int main() {
    // 比如这里printf函数里的第一个参数"my age is %d"这整个是个字符串字面量、包括%d在内，第二个参数是个整型字面量
    printf("my age is %d\n", 10);
    
    return 0;
}
```

* 常变量

变量是指可以变化的量，其中第一次赋值后还能再次赋值的变量是纯变量——通常我们创建的都是纯变量，第一次赋值后不能再次赋值的变量是常变量——const修饰的变量就是常变量。

```c
int main() {
    const int i = 10;
//    i = 20; // 编译报错，不能修改
    
    return 0;
}
```

注意：我们之所以称const修饰的变量为常变量，是因为它的本质其实还是个变量，“常”主要体现在我们不能通过变量名来直接修改它而已，但它并非真得就不能修改，比如我们可以通过指针越界访问的方式来修改它。

```c
#include <stdio.h>

int main() {
    const int i = 10;
    
    int i1 = 20;
    int *p = &i1;
    
    // 栈区分配内存是从高地址往低地址分配的，所以i的地址要比i1的地址高，所以p + 1就是i的地址
    printf("i的地址 = %p\n", &i); // i的地址 = 0x30410b248
    printf("i1的地址 = %p\n", &i1); // i1的地址 = 0x30410b244
    printf("i1的地址 = %p\n", p); // i1的地址 = 0x30410b244
    printf("i的地址 = %p\n", p + 1); // i的地址 = 0x30410b248
    
    // 通过指针越界访问的方式来修改常变量
    *(p + 1) = 30;
    printf("%d\n", i); // 30
    
    return 0;
}
```

补充：下面是const几种常见的用法。

```c
int main() {
    int i = 10;
    int i1 = 20;
    
    // const修饰的是*p，所以*p不能变，但是p可以变
    const int *p = &i;
    p = &i1;
//    *p = i1; // 编译报错，不能修改
    
    // const修饰的是p1，所以p1不能变，但是*p1可以变
    int * const p1 = &i;
//    p1 = &i1; // 编译报错，不能修改
    *p1 = i1;
    
    // const修饰的是p2和*p2，所以p2和*p2都不能变
    const int * const p2 = &i;
//    p2 = &i1; // 编译报错，不能修改
//    *p2 = i1; // 编译报错，不能修改
    
    return 0;
}
```

* 宏常量

宏常量在定义后如果你想修改，编译器就会报错，这也是为什么我们把它称为常量的原因。究其本质，其实宏常量在编译结束后就不存在于我们的代码里了，全部被替换成了字面常量，都不存在了我们还怎么修改它呢。

```c
#define MAX 100

int main() {
//    MAX = 1000; // 编译报错，不能修改
    
    return 0;
}
```

* 枚举常量

枚举常量在定义后如果你想修改，编译器就会报错，这也是为什么我们把它们称为常量的原因。究其本质，其实枚举常量在编译结束后也不存在于我们的代码里了，全部被替换成了字面常量，都不存在了我们还怎么修改它呢。

```c
enum season {
    // 枚举类型里的成员就是枚举常量
    SPRING = 10,
    SUMMER,
    AUTUMN = 20,
    WINTER,
};

int main() {
//    SUMMER = 110; // 编译报错，不能修改
    
    return 0;
}
```
