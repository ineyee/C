## 七、数据类型：基本数据类型

#### 1、字符类型

###### 1.1 字符类型的基础知识

* char类型变量的声明及初始化

```c
char c = 'A';
```

* char类型变量的赋值

```c
c = 'a';
```

* char类型变量的读取

```c
printf("%c\n", c); // a
```

###### 1.2 字符类型的进阶知识

* char类型的变量用来存储什么？

char类型的变量用来存储单字节字符，这里说的单字节字符是指ASCII码表里那样的单字节字符，字符一般用单引号''括起来，字符串才用双引号""。

* char类型的变量所对应的内存有多大？它的取值范围是多少？

char类型的变量所对应的内存为1个字节，这也是它为什么只能存储ASCII码表里那样的单字节字符，而不能存储GBK码表或Unicode码表里汉字这样的二、三字节字符，再强调一遍，char类型的变量只能存储ASCII码表里的单字节字符，ASCII码表里一共也就128个单字节字符。

* 单字节字符在内存中到底是以什么样的二进制存储的？

因为计算机只能存储二进制，没法直接存储什么'A'、'a'、'0'、'\0'等这样的单字节字符，所以单字节字符在内存中其实是以单字节字符对应的ASCII码值的二进制存储的，比如：

```c
char c = 'A';
char c1 = 'a';
char c2 = '0';
char c3 = '\0';
```

'A'的ASCII码值为65，所以变量c0所对应的内存里存储的就是0100_0001这个二进制；'a'的ASCII码值为97，所以变量c1所对应的内存里存储的就是0110_0001这个二进制；'0'的ASCII码值为48，所以变量c2所对应的内存里存储的就是0011_0000这个二进制；'\0'的ASCII码值为0，所以变量c3所对应的内存里存储的就是0000_0000这个二进制。

至此我们就发现，**我们除了可以把char类型当成是一个字符类型来使用，还可以把它当成是一个只占1个字节的有符号整型来使用**，即char类型除了可以用来存储单字节字符，还可以用来存储整数，只不过这个整数的范围很小，只占1个字节，[-2^7, 2^7-1] = [-128, 127]，这个我们在后面说到整型的时候会专门再说一遍。

* 补充：转义字符

转义字符是指一些有特殊含义的单字节字符，你别看它是由两个字符组成的就认为它不是单字节字符，前面那个斜杠只是为了转义用的，有实际意义的只是斜杠后面那个字符，因此它本质上还是个一个单字节字符，存在于ASCII码表里的，所以可以被赋值给char类型的变量，常用的转义字符有：

| 转义字符 |       含义       |
| :------: | :--------------: |
|   \\'    |      单引号      |
|   \\"    |      双引号      |
|   \\\    |      反斜杠      |
|    \r    |       回车       |
|    \n    |       换行       |
|    \0    | 字符串的结束标识 |

也就是说当我们的代码里需要出现单引号、双引号、反斜杠、回车、换行、字符串的结束标识时，就得用转义字符。

#### 2、整型

###### 2.1 整型的基础知识

* int类型变量的声明及初始化

```c
int i = 10;
```

* int类型变量的赋值

```c
i = 20;
```

* int类型变量的读取

```c
printf("%d\n", i); // 20
```

###### 2.2 整型的进阶知识

* 整型的变量用来存储什么？

整型的变量用来存储整数；无符号整型的变量用来存储0、正数——这种东西一般偏向于无数学意义的“数据”的感觉，比如我们采集到的音视频数据最好赋值给无符号整型的变量；有符号整型的变量用来存储负数、0、正数——这种东西一般偏向于有数学意义的“数值”的感觉，比如要参与加减乘除等运算的数值最好赋值给有符号整型的变量。因此我们有一个不成文的规定，**unsigned xxx只能用来接收“数据”，其它的“数值”你统一用signed xxx就行了，这样将来别人看到我们的代码就不会产生二义性，如果是unsigned xxx，他们就知道里面存储的肯定就是无数学意义的“数据”，如果是signed xxx，他们就知道里面存储的肯定是有数学意义的“数值”。**

* 整型的变量所对应的内存有多大？它的取值范围是多少？

**注意：不同数据类型的变量所对应的内存有多大，这个其实是不固定的，是由编译器决定的，比如同样都是int，有的编译器下可能就是占2个字节，有的编译器下可能就是占4个字节**，以下列出的仅仅是现在比较常见的情况：

|   无符号整型   | 占用内存 |                       取值范围                        |
| :------------: | :------: | :---------------------------------------------------: |
| unsigned char  | 1个字节  |                 [0, 2^8-1] = [0, 255]                 |
| unsigned short | 2个字节  |               [0, 2^16-1] = [0, 65535]                |
|  unsigned int  | 4个字节  |      [0, 2^32-1] = [0, 4294967295]（一共10位数）      |
| unsigned long  | 8个字节  | [0, 2^64-1] = [0, 18446744073709551615]（一共20位数） |

| 有符号整型 | 占用内存 |                           取值范围                           |
| :--------: | :------: | :----------------------------------------------------------: |
|    char    | 1个字节  |                 [-2^7, 2^7-1] = [-128, 127]                  |
|   short    | 2个字节  |              [-2^15, 2^15-1] = [-32768, 32767]               |
|    int     | 4个字节  |   [-2^31, 2^31-1] = [-2147483648, 217483647]（一共9位数）    |
|    long    | 8个字节  | [-2^63, 2^63-1] = [-9223372036854775808, 9223372036854775807]（一共19位数） |

* 整数在内存中到底是以什么样的二进制存储的？

无符号整型在内存中是直接以数值的二进制存储的，比如：

```c
unsigned char c = 0;
unsigned char c1 = 11;
```

变量c所对应的内存里存储的就是0000_0000这个二进制，变量c1所对应的内存里存储的就是0000_1011这个二进制。

有符号整型在内存中是以数值的二进制的补码存储的，比如：

```c
char c = 0;
char c1 = 11;
char c2 = -11;
```

变量c所对应的内存里存储的就是0000_0000这个二进制，变量c1所对应的内存里存储的就是0000_1011这个二进制，变量c2所对应的内存里存储的就是1111_0101这个二进制。

* 补充：有符号整型数值的二进制的原码、反码、补码

有符号整型数值的二进制有三种表示方法：原码、反码、补码，注意原码、反码、补码只针对有符号整型，无符号整型没有这么一说。

所谓原码是指二进制的第一位为符号位，0代表正数、1代表负数，后面的位数为数值位，存储的是数值的绝对值，比如：

|                      | 符号位 |  数值位  |
| :------------------: | :----: | :------: |
|  char c = 0;的原码   |   0    | 000_0000 |
| char c1 = 11;的原码  |   0    | 000_1011 |
| char c2 = -11;的原码 |   1    | 000_1011 |

所谓反码是指正数的反码和原码是一样的，但负数的反码是保持原码的符号位不变，数值位按位取反（0变1、1变0），比如：

|                      | 符号位 |  数值位  |
| :------------------: | :----: | :------: |
|  char c = 0;的反码   |   0    | 000_0000 |
| char c1 = 11;的反码  |   0    | 000_1011 |
| char c2 = -11;的反码 |   1    | 111_0100 |

所谓补码是指正数的补码和原码是一样的，但负数的补码是反码的末位加1，比如：

|                      | 符号位 |  数值位  |
| :------------------: | :----: | :------: |
|  char c = 0;的补码   |   0    | 000_0000 |
| char c1 = 11;的补码  |   0    | 000_1011 |
| char c2 = -11;的补码 |   1    | 111_0101 |

以上就说明了什么是原码、反码、补码，那你可能会问：既然有符号整型二进制的最高位已经代表符号位了，那为什么不设计数值位也直接以绝对值的二进制存储呢？

ok，现在我们假设有符号整型的数值位也直接以绝对值的二进制存储，那11和-11在内存中就是下面这样：

|                | 符号位 |  数值位  |
| :------------: | :----: | :------: |
| char c1 = 11;  |   0    | 000_1011 |
| char c2 = -11; |   1    | 000_1011 |

而CPU运算器里加法器的设计非常简单，那就是把两块内存里的数值给加起来就完事了，这种设计对于无符号整型的数值来说是完全正确的，但对于有符号整型就不一定正确了，比如现在把c1和c2加起来，0000_1011 + 1000_1011 = 1001_0110 = -22，本来11 + (-11)应该等于0的，这样就算错了。如果想要算对有两种办法，一是修改CPU运算器里加法器的设计，让它兼容有符号整型的运算，但这不太好搞，因为加法器它只知道相加，它可不知道你那个二进制最高位的1是符号位还是数值位的最高位，因此还有第二种办法就是修改内存里存储的数据，实际也是采用这种办法的，比如现在有符号整型是以数值的二进制的补码存储的：

|                | 符号位 |  数值位  |
| :------------: | :----: | :------: |
| char c1 = 11;  |   0    | 000_1011 |
| char c2 = -11; |   1    | 111_0101 |

我们还是做加法运算，CPU运算器里的加法器会直接把它们相加，0000_1011 + 1111_0101 = 0001_0000_0000 = 0000_0000 = 0，这样就算对了。因此有符号整型以补码的形式存储可以简化CPU运算器的设计，统一无符号整型和有符号整形的运算。

#### 3、浮点型

###### 3.1 浮点型的基础知识

* double类型变量的声明及初始化

```c
double d = 3.14;
```

* double类型变量的赋值

```c
d = 3.1415926;
```

* double类型变量的读取

```c
printf("%.2lf\n", d); // 3.14
```

###### 3.2 浮点型的进阶知识

* 浮点型的变量用来存储什么？

浮点型的变量用来存储小数。

* 浮点型的变量所对应的内存有多大？它的取值范围是多少？

| 单精度浮点型 | 占用内存 |                           取值范围                           |    精度     |
| :----------: | :------: | :----------------------------------------------------------: | :---------: |
|    float     | 4个字节  | [-3.4 * 10^38, 3.4 * 10^38]（因为不是直接存储二进制、所以取值范围大的离谱） | 小数点后6位 |

| 双精度浮点型 | 占用内存 |                           取值范围                           |     精度     |
| :----------: | :------: | :----------------------------------------------------------: | :----------: |
|    double    | 8个字节  | [-1.8 * 10^308, 1.8 * 10^308]（因为不是直接存储二进制、所以取值范围大的离谱） | 小数点后15位 |

* 小数在内存中到底是以什么样的二进制存储的？

**小数在内存中不是直接以数值的二进制存储的，而是以二进制科学计数法来存储的：**

> **(-1)^s * f * 2^e，1<= f < 2**

**其中s为符号位、e为指数位、f为尾数位。**

单精度浮点型的32位里，最高1位为符号位（存储的是符号s，0表示正小数、1表示负小数），中间8位为指数位（存储的是指数e + 127），后面23位为尾数位（存储的是尾数f的小数部分）；双精度浮点型的64位里，最高1位为符号位（存储的是符号s，0表示正小数、1表示负小数），中间11位为指数位（s存储的是指数e + 1023），后面52位为尾数位（存储的是尾数f的小数部分）。

比如：

```c
float f = 5.7;
```

第一步：先把这个小数转换成二进制101.1_0110_0110_0110_0110_0110...，写成科学计数法就是 (-1)^0 * 1.011_0110_0110_0110_0110_0110... * 2^2，所以s = 0、f = 1.011_0110_0110_0110_0110_0110...、e = 2

第二步：符号位的话，直接把0存进去就行了

第三步：指数位的话，因为这8位是被当作无符号整型来读写的，但是指数可以是正也可以是负，所以为了更好地表示负指数的存储，这里设计指数位不是直接存储e，而是存储e + 127，等到读取的时候再减掉127就行了，所以指数位里存储的是2 + 127 = 0000_0010 + 0111_1111 = 1000_0001

第四步：尾数位的话，我们上面说过“f就是把原来二进制的整数部分搞得只剩下一个1、小数点向左移动或向右移动得到的”，可见f的整数部分绝对会有一个“1”，所以这里设计尾数位不存储整数部分只存储小数部分，等到读取的时候再加个1就行了，这样设计的目的就是省出1位来、让那23位全部用来存储小数部分，从而提高精度，所以尾数位里存储的就是011_0110_0110_0110_0110_0110，后面无限循环的部分就被截取掉了，因为只能存储23位

最终：所以变量f所对应的内存里存储的就是0 1000_0001 011_0110_0110_0110_0110_0110这个二进制

* 补充：浮点型的精度

（1）为什么说小数存储在内存中是有可能丢精度的？

最典型的例子就是0.7，0.7在存储到内存中时，第一步就是要把它转换成二进制，而它转换成二进制后是无限循环的，而float顶多存储23位的尾数、double顶多存储52位的尾数，所以0.7存储在内存中必然会丢精度，因此在和金钱相关的运算上千万不要使用小数来参与计算。

（2）为什么说float的精度为小数点后6位，double的精度为小数点后15位？

因为float的尾数位为23位，这23位可以表示的小数范围为0~2^23 ≈ 0~8.4*10^6，所以它的精度顶多到小数点后6位，而double的尾数位为52位，这52位可以表示的小数范围为0~2^52 ≈ 0~4.5×10^15，所以它的精度顶多到小数点后15位，也就是说如果我们把一个小数位有7位的小数交给float去存储，到时候拿出来前6位是没问题的，但第7位可能就乱七八糟不是你之前存的时候那个值了，double也同理。

#### 4、布尔类型

###### 4.1 布尔类型的基础知识

* bool类型变量的声明及初始化

```c
bool b = true;
```

* bool类型变量的赋值

```c
b = false;
```

* bool类型变量的读取

```c
printf("%d\n", b); // 0
```

###### 4.2 布尔类型的进阶知识

* bool类型的变量用来存储什么？

bool类型的变量用来存储布尔值，这里说的布尔值是指true和false这两个字面常量。

* bool类型的变量所对应的内存有多大？它的取值范围是多少？

bool类型的变量占用1个字节的内存，它只能存储true和false这两个字面常量。

* true和false在内存中到底是以什么样的二进制存储的？

**bool类型的true其实就是char类型的1，bool类型的false其实就是char类型的0。**

```c
bool b = true;
bool b1 = false;
```

所以变量b所对应的内存里存储的就是0000_0001这个二进制，变量b1所对应的内存里存储的就是0000_0000这个二进制。

* 补充：bool类型的定义

bool类型存在于<stdbool.h>这个库里，bool类型的定义为：

```c
#define true 1
#define false 0
```
