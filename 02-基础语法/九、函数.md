## 九、函数

#### 1、函数的基础知识

###### 1.1 函数是什么

**函数是指一段代码的集合，它由函数的作用域类型、函数的返回值、函数名、函数的参数、函数的执行体五大部分组成：**

> **函数的作用域类型 函数的返回值 函数名(函数的参数) {**
> 	**函数的执行体**
> **}**

* **函数的作用域类型：用来表明函数的作用域是整个项目还是当前源文件**
* **函数名：拿到函数名就是拿到了函数的地址**
* 其它三部分：下面说

###### 1.2 函数的声明

函数的声明一般放在头文件里。

无参无返回值：

```c
void fun();
```

无参有返回值：

```c
int fun1();
```

有参无返回值：

```c
void fun2(int i1, int i2);
```

有参有返回值：

```c
int fun3(int i1, int i2);
```

###### 1.3 函数的实现

函数的实现一般放在源文件里。

```c
void fun() {
    printf("10\n");
}
```

```c
int fun1() {
    return 10;
}
```

```c
void fun2(int i1, int i2) {
    printf("%d\n", i1 + i2);
}
```

```c
int fun3(int i1, int i2) {
    return i1 + i2;
}
```

###### 1.4 函数的调用

```c
#include <stdio.h>

int main() {
    fun(); // 10
    printf("%d\n", fun1()); // 10
    fun2(10, 20); // 30
    printf("%d\n", fun3(10, 20)); // 30
  
    return 0;
}
```

###### 1.5 函数的本质

**函数的本质其实也是一段连续的内存。**

#### 2、函数的进阶知识

###### 2.1 函数用来存储什么？

**函数用来存储一段代码，这段代码除了包含函数的执行体之外，还包含函数的参数入栈相关的代码、函数的返回值存入寄存器相关的代码、维持栈内存平衡相关的代码等。**

###### 2.2 函数所对应的内存有多大？

这主要取决于代码量，没有一个固定的值，也没有一个固定的计算方法。

###### 2.3 “一段代码”在内存中到底是以什么样的二进制存储的？

函数的执行体、函数的参数入栈相关的代码、函数的返回值存入寄存器相关的代码、维持栈内存平衡相关的代码等都会先转换成一条一条的汇编，然后再转换成一条一条的机器指令，汇编和机器指令是一对一的，汇编我们还是能看得懂的，0101这样的机器指令我们就看不懂了，所以这里研究“一段代码”对应的二进制没多大意义，非要研究的话研究一下“一段代码”对应的汇编就足够了、见《汇编》这一篇。

###### 2.4 关于函数名

首先要知道函数名就是函数所对应的内存的地址，其次要知道C语言里函数是二等公民，因此我们不能把一个函数赋值给变量，也不能把函数作为另一个函数的参数和返回值，如果有传递函数的需求，得通过函数指针来实现。

所谓函数指针就是指一个指针指向了一个函数，详细地说就是一个函数指针变量所对应的内存里存储了一个地址，这个地址所指向的那块内存里存储的是一个函数，函数指针主要有两个应用场景：

* 单纯地希望外界传进来一个函数，我们在函数内部调用

```c
#include <stdio.h>

// 加法函数
int add(int a, int b) {
    return a + b;
}

// 减法函数
int sub(int a, int b) {
    return a - b;
}

// 乘法函数
int mul(int a, int b) {
    return a * b;
}

// 除法函数
int div(int a, int b) {
    return a / b;
}

// 这里的int (int, int)一个函数类型，calc_t是该函数类型的别名
typedef int (calc_t)(int, int);
// 这里我们通过返回值的方式把calc函数的结果告诉外界
int calc(calc_t *calc, int a, int b) {
    printf("计算开始\n");
    int ret = calc(a, b);
    printf("计算结束==%d\n", ret);
    return ret;
}
```

* 回调函数，即通过回调函数把内部的一些东西回调给外界

```c
#include <stdio.h>

// 加法函数
int add(int a, int b) {
    return a + b;
}

// 减法函数
int sub(int a, int b) {
    return a - b;
}

// 乘法函数
int mul(int a, int b) {
    return a * b;
}

// 除法函数
int div(int a, int b) {
    return a / b;
}

// 这里的int (int, int)一个函数类型，calc_t是该函数类型的别名
typedef int (calc_t)(int, int);
// 再定义一个函数类型
typedef void (callback_t)(int);
// 这里我们通过回调函数的方式把calc函数的结果告诉外界
void calc(calc_t *calc, int a, int b, callback_t *callback) {
    printf("计算开始\n");
    int ret = calc(a, b);
    callback(ret);
    printf("计算结束==%d\n", ret);
}
```

###### 2.5 关于函数的参数

* 形参和实参

**函数在声明时的参数和函数在实现时执行体里使用的参数都是形参，所以形参的生命周期和作用域都是该函数所在的大括号**，而函数在调用时实实在在传进来的参数才是实参，实参就是传递给形参的，那么这个传递就分为值传递和地址传递。

* 函数参数的值传递和地址传递

**函数的参数如果是非指针类型的就是值传递，如果是指针类型的就是地址传递，所谓值传递和地址传递是指我们到底是把外界变量的值还是地址传递给形参了。形参在栈上有自己的内存，所以如果是值传递的话就意味着形参所对应的内存里拷贝了一份外界变量的值来存，地址传递的话就意味着形参所对应的内存里拷贝了一份外界变量的地址来存，因此改变形参是绝对不会改变外界变量的值的，但如果函数的参数是指针类型的话，我们倒是可以通过指针拿到外界变量的值来修改。**

```c
#include <stdio.h>

// 值传递
void swap(int i1, int i2) {
    i1 = i1 ^ i2;
    i2 = i1 ^ i2;
    i1 = i1 ^ i2;
}

int main() {
    int i1 = 10;
    int i2 = 20;
    swap(i1, i2);
    printf("%d %d\n", i1, i2); // 10 20，确实没有交换i1和i2的值
  
    return 0;
}
```

```c
#include <stdio.h>

// 地址传递
void swap(int *i1, int *i2) {
    *i1 = *i1 ^ *i2;
    *i2 = *i1 ^ *i2;
    *i1 = *i1 ^ *i2;
}

int main() {
    int i1 = 10;
    int i2 = 20;
    swap(&i1, &i2);
    printf("%d %d\n", i1, i2); // 20 10，确实交换了i1和i2的值
  
    return 0;
}
```

* 函数参数的设计规范

  * 什么时候用值传递？什么时候用地址传递？

    * 对于基本数据类型、非连续内存的枚举类型和指针类型，如果我们的函数内部不想修改外界变量的值，就用值传递，如果我们的函数内部想修改外界变量的值，就用地址传递

      ```c
      // 如果我们的函数内部不想修改外界变量的值，就用值传递
      void test(int p);
      
      // 如果我们的函数内部想修改外界变量的值，就用地址传递
      void test1(int *p);
      ```

    * 对于连续内存的结构体类型、数组、函数，建议一定要以地址传递，因为没必要在栈区再分配一段那么大的内存来拷贝值了，拷贝个地址就行了，否则非常浪费栈内存；这种情况下，如果我们的函数内部不想修改外界指针所指向的内容，那就再用const修饰一下，如果我们的函数内部想修改外界指针所指向的内容，那就不要用const修饰

      ```c
      // 地址传递：传递结构体使用结构体指针
      // 如果我们的函数内部不想修改外界指针所指向的内容，那就再用const修饰一下
      void test2(const person_t *p);
      
      // 地址传递：传递数组使用数组首元素数据类型对应的指针
      // 如果我们的函数内部想修改外界指针所指向的内容，那就不要用const修饰
      void test3(int *p);
      
      // 地址传递：传递函数使用函数指针
      // 如果我们的函数内部不想修改外界指针所指向的内容，那就再用const修饰一下
      typedef int (fun_t)(int, int);
      void test4(const fun_t *p);
      ```

  * 值传递和地址传递二义性的处理

    上面test1函数和test3函数的声明一模一样，也就是说它们的参数明显有二义性，我们无法直接从函数的声明一眼就看出这个函数到底是想接收一个整型指针变量，还是接收一个整型数组的地址，因此我们有一个不成文的约定，**只有修改一个值的时候才明确写成int \*这种，而如果是想接收一段连续的内存空间如数组，则不要写明int \*这种，而使用void \*、等使用时再强转**

    ```c
    // int *，代表接收一个整型指针
    void test1(int *p);
    
    // void *，代表接收一个连续的内存空间，等使用时再强转
    void test3(void *p);
    ```

  * 传递字符串时，如果传递的是字符串字面常量，那就必须得用const char \*传递，因为前面我们已经说过了字符串字面常量就是const char \*；如果传递的不是字符串字面常量，那就代表这个字符串是可变的——即一个字符数组，此时用char \*来传递就行了，注意这里是个特例，就不要用void \*来传递了，因为我们很明确就是个字符串嘛

**这样将来别人一看到我们的代码，如果发现函数的参数是基本数据类型的值传递，那就表明这个函数希望接收一个基本数据类型的值，而且函数内部肯定不会修改外界变量的值；如果发现函数的参数是基本数据类型的指针传递，那就表明这个函数希望接收一个基本数据类型的指针，而且函数内部肯定会修改外界变量的值；如果发现函数的参数是void \*，那就表明这个函数希望接收一个连续内存空间的数据，如结构体、数组、函数，如果带const那就表明函数内部肯定不会修改外界变量的值，不带const那就表明=函数内部肯定会修改外界变量的值；如果发现函数的参数是const char \*，那就表明这个函数希望接收一个字符串字面常量，如果是char \*，那就表明这个函数希望接收一个字符数组。**

###### 2.6 关于函数的返回值

**函数的返回值是存放在寄存器里的。**

* 如果返回的是基本数据类型、非连续内存的枚举类型和指针类型，我们约定直接返回就可以了

  ```c
  int test();
  ```

* 如果返回的是连续内存的结构体类型、数组、函数，建议一定要以地址传递，避免占用过多的寄存器资源，上面我们已经约定了基本数据类型、非连续内存的枚举类型和指针类型肯定是直接返回，所以在返回值上见到*就代表是一段连续的内存空间，而不是某个值的地址，但需要注意的是返回的指针千万不能是个局部变量的地址——即野指针

  ```c
  int *test();
  ```

  
