## 十、运算符

#### 1、算数运算符

* 加+、减-、乘*、除/
  * 整型和整型之间的运算，结果还是整型，如果不能整除则向下取整、不是向上取整、也不是四舍五入
  * 浮点型和浮点型之间的运算，结果还是浮点型
  * 整型和浮点型之间的运算，结果是浮点型
* 取余%：取余运算符的操作数只能是整型，不能出现浮点型
  * 取余运算符余数的正负性总是跟随运算符左边操作数的正负性
  * 取余运算符的一个特性就是：给定任意一个数n，对m取余，余数的取值范围为[0, m - 1]，因此取余运算符常用来获取在某个范围内的数字
* 位运算符：位运算符的操作数只能是整型，不能出现浮点型
  * 按位左移：a << b，每左移一位就相当于乘以一次2，也就是说a按位左移b位就相当于a乘以2^b
  * 按位右移：a >> b，每右移一位就相当于除以一次2，也就是说a按位右移b位就相当于a除以2^b
  * 按位取反：~a，a的二进制每一位都0变1、1变0
  * 按位与：a & b，a和b的二进制每一对儿都是1才是1，否则就是0
  * 按位或：a | b，a和b的二进制每一对儿只要有一个1就是1，否则才是0
  * 按位异或：a ^ b，a和b的二进制每一对儿不相等时就是1，否则就是0

> 因此如果你的代码里但凡有乘以2的地方，建议用<< 1来代替，但凡有除以2的地方，建议用>> 1来代替，但凡有a乘以2^b、a除以2^b的地方，建议用a << b、a >> b运算来代替乘、除运算，因为位运算的效率是非常高的。
>
> 建议用(a & 1 == 0)代替(a % 2 == 0)来判断a的奇偶性，同样是因为位运算的效率是非常高的，那为什么a & 1能判断a的奇偶性呢？其实a的奇偶性只取决于它二进制的最后一位，只要最后一位是1那a就是奇数，最后一位是0那a就是偶数，这是为什么呢？因为前面的高位全都是乘以2^1、2^2、2^3这种了，也就是说前面的高位加起来肯定是2的倍数，只有最后一位有可能是1 * 2^0 = 1或0 * 2^0 = 0，它才是对a的奇偶性起决定性的一位，因此我们只要把a二进制的最后一位拿到，看看它是1那a就是奇数，是0那a就是偶数，那怎么拿到a二进制的最后一位呢？按位与1呗，a前面的高位全给它干成0，只有最后一位保留a的原样就行了。
>
> 可以用按位或来实现位移枚举。
>
> 可以使用按位异或来实现“不引入第三个变量，交换a、b两个变量的值”，搞这么三下就可以了，自己可以推导下对不对：
>
> a = a ^ b;
>
> b = a ^ b;
>
> a = a ^ b;

#### 2、赋值运算符

**注意：赋值运算符用在基本数据类型的赋值上时为值赋值，用在地址类型如指针的赋值上时为地址赋值**

* 基本赋值：=
* 加减乘除赋值：+=、-=、*=、/=
* 取余赋值：%=
* 位运算赋值：<<=、>>=、~=、&=、|=、^=

#### 3、比较运算符

**注意：比较运算符用在基本数据类型的比较上时为值比较，用在地址类型如指针的比较上时为地址比较**

* 等于：==
* 不等于：!=
* 小于：<
* 大于：>
* 小于等于：<=
* 大于等于：>=

#### 4、逻辑运算符

* 逻辑与（存在短路现象）：&&
* 逻辑或（存在短路现象）：||
* 逻辑非：!

#### 5、访问运算符

* 结构体变量和结构体指针变量访问成员变量运算符：.和->
* 定义指针变量和读写指针变量里的地址所指向内存里的值运算符：*
* 取地址运算符：&

#### 6、其它运算符

* 三目运算符?:：如果if-else语句的执行体非常简单的话，可以用三目运算符来代替

* sizeof：sizeof用来获取一个变量所对应的内存有多大，我们可以直接把变量名放进去，也可以把数据类型放进去，它不能用来获取一个函数所对应的内存有多大

```c
#include <stdio.h>

int main() {
    int i = 10;
    printf("%lu\n", sizeof(i)); // 4
    printf("%lu\n", sizeof(int)); // 4
    
    return 0;
}
```

* 自增自减运算符
  * 前缀自增自减++a、--a：++a完全等价于a += 1，--a完全等价于a -= 1
  * 后缀自增自减a++、a--：a++也完全等价于a += 1，a--也完全等价于a -= 1

```c
// 那前缀自增自减和后缀自增自减有什么区别呢？
// 其实前缀自增自减和后缀自增自减对操作数本身来说是没有任何区别的，它们的区别主要就在于一句代码里除了有自增自减运算，还有别的运算时就会影响别的运算的结果了，而如果一句代码里只有自增自减运算而没有其它运算，那么它们就没有任何区别，详见下面几个例子：

// 当一句代码里++a、--a没有跟别的运算混合在一起使用时，++a完全等价于a += 1，--a完全等价于a -= 1
void test() {
    int a = 1;
    ++a;
    printf("%d\n", a); // 2

    int b = 1;
    --b;
    printf("%d\n", b); // 0
}

// 当一句代码里a++、a--没有跟别的运算混合在一起使用时，a++完全等价于a += 1，a--完全等价于a -= 1
void test1() {
    int a = 1;
    a++;
    printf("%d\n", a); // 2

    int b = 1;
    b--;
    printf("%d\n", b); // 0
}

// 当一句代码里++a、--a跟别的运算混合在一起使用时，才有“先++、--，后使用”的说法
void test2() {
    int a = 1;
    int b = 3;

    // 前缀运算符就是“先++、--，后使用”，很明显是先对a进行++操作————即先把a += 1，然后再使用a完成别的运算————即再把a赋值给b
    b = ++a;

    printf("%d %d\n", a, b); // 2 2
}

// 当一句代码里a++、a--跟别的运算混合在一起使用时，才有“先使用，后++、--”的说法
void test3() {
    int a = 1;
    int b = 3;

    // 后缀运算符就是“先使用，后++、--”，很明显是先使用a完成别的运算————即先把a赋值给b，然后再对a进行++操作————即再把a += 1
    b = a++;

    printf("%d %d\n", a, b); // 2 1
}
```
